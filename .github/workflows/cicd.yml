name: Fractal Capstone CI/CD

on:
  # Uncomment this to run on every push to main
  # push:
  #   branches: [ main ]
  workflow_dispatch:

env:
  # e.g. "fractalcapacr.azurecr.io"
  REGISTRY_LOGIN_SERVER: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
  NAMESPACE: fractal-capstone

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      # 1) Checkout repo
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Azure login using Service Principal
      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # 3) Extract ACR name (fractalcapacr from fractalcapacr.azurecr.io)
      - name: Extract ACR name
        id: acr
        run: |
          REG_NAME=$(echo "${{ env.REGISTRY_LOGIN_SERVER }}" | cut -d'.' -f1)
          echo "REGISTRY_NAME=$REG_NAME" >> $GITHUB_OUTPUT

      # 4) Login to ACR (uses Docker on GitHub runner)
      - name: ACR login
        run: |
          az acr login --name ${{ steps.acr.outputs.REGISTRY_NAME }}

      # 5) Build & push BACKEND (AMD64)
      - name: Build and push backend image
        run: |
          docker build \
            -t ${{ env.REGISTRY_LOGIN_SERVER }}/loan-backend:${{ github.sha }} \
            -t ${{ env.REGISTRY_LOGIN_SERVER }}/loan-backend:latest \
            ./backend

          docker push ${{ env.REGISTRY_LOGIN_SERVER }}/loan-backend:${{ github.sha }}
          docker push ${{ env.REGISTRY_LOGIN_SERVER }}/loan-backend:latest

      # 6) Build & push FRONTEND (AMD64)
      - name: Build and push frontend image
        run: |
          docker build \
            -t ${{ env.REGISTRY_LOGIN_SERVER }}/loan-frontend:${{ github.sha }} \
            -t ${{ env.REGISTRY_LOGIN_SERVER }}/loan-frontend:latest \
            ./frontend

          docker push ${{ env.REGISTRY_LOGIN_SERVER }}/loan-frontend:${{ github.sha }}
          docker push ${{ env.REGISTRY_LOGIN_SERVER }}/loan-frontend:latest

      # 7) Trivy scan backend image
      # WHY: Security vulnerability scan (pull image first since it's in ACR now)
      - name: Trivy scan backend
        run: |
          docker pull ${{ env.REGISTRY_LOGIN_SERVER }}/loan-backend:${{ github.sha }}
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
            --exit-code 1 \
            --severity HIGH,CRITICAL \
            --ignore-unfixed \
            --quiet \
            --table-mode summary \
            ${{ env.REGISTRY_LOGIN_SERVER }}/loan-backend:${{ github.sha }}

      # 8) Trivy scan frontend image
      - name: Trivy scan frontend
        run: |
          docker pull ${{ env.REGISTRY_LOGIN_SERVER }}/loan-frontend:${{ github.sha }}
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
            --exit-code 1 \
            --severity HIGH,CRITICAL \
            --ignore-unfixed \
            --quiet \
            --table-mode summary \
            ${{ env.REGISTRY_LOGIN_SERVER }}/loan-frontend:${{ github.sha }}


      # 9) Set AKS context
      # WHY: So kubectl commands in this job talk to your AKS cluster.
      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      # 10) Apply Kubernetes manifests (idempotent)
      # WHY: Ensure namespace + services + deployments exist/updated.
      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/frontend-blue-config.yaml
          kubectl apply -f k8s/frontend-green-config.yaml
          kubectl apply -f k8s/backend-service.yaml
          kubectl apply -f k8s/frontend-service.yaml
          kubectl apply -f k8s/backend-deployment.yaml
          kubectl apply -f k8s/frontend-deployment-blue.yaml
          kubectl apply -f k8s/frontend-deployment-green.yaml

      # 11) Update backend to new image + wait for rollout
      - name: Deploy backend
        run: |
          kubectl set image deployment/loan-backend-deployment \
            loan-backend=${{ env.REGISTRY_LOGIN_SERVER }}/loan-backend:${{ github.sha }} \
            -n ${{ env.NAMESPACE }}

          kubectl rollout status deployment/loan-backend-deployment \
            -n ${{ env.NAMESPACE }} --timeout=300s

      # 12) Blue/Green rollout for frontend
      - name: Blue-Green deploy frontend
        run: |
          NS=${{ env.NAMESPACE }}

          # Get current live color
          CURRENT_COLOR=$(kubectl get svc loan-frontend-svc -n $NS -o jsonpath='{.spec.selector.version}')
          echo "Current live color: $CURRENT_COLOR"

          if [ "$CURRENT_COLOR" = "blue" ]; then
            NEW_COLOR="green"
          else
            NEW_COLOR="blue"
          fi

          echo "Deploying new version to: $NEW_COLOR"

          # Update image on NEW_COLOR deployment
          kubectl set image deployment/loan-frontend-$NEW_COLOR \
            loan-frontend=${{ env.REGISTRY_LOGIN_SERVER }}/loan-frontend:${{ github.sha }} \
            -n $NS

          # Wait for the rollout
          kubectl rollout status deployment/loan-frontend-$NEW_COLOR \
            -n $NS --timeout=300s

          # Switch service selector to NEW_COLOR
          echo "Switching Service to: $NEW_COLOR"
          kubectl patch svc loan-frontend-svc -n $NS \
            -p "{\"spec\": {\"selector\": {\"app\": \"loan-frontend\", \"version\": \"$NEW_COLOR\"}}}"

          echo "Blue-Green switch completed."
